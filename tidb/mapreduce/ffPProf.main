package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path"
	"runtime"
	"runtime/pprof"
	"strconv"
	"time"
)

var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to file")
var memprofile = flag.String("memprofile", "", "write mem profile to file")
var interval = flag.String("interval", "100", "intervals for goroutine counter")

func testDataScale() ([]DataSize, []int) {
	dataSize := []DataSize{1 * MB, 10 * MB, 100 * MB, 500 * MB, 1 * GB}
	nMapFiles := []int{5, 10, 20, 40, 60}

	//	dataSize := []DataSize{1 * GB}
	//	nMapFiles := []int{60}

	return dataSize, nMapFiles
}

const (
	dataDir = "/tmp/mr_homework"
	nCase   = 1
)

func dataPrefix(i int, ds DataSize, nMap int) string {
	return path.Join(dataDir, fmt.Sprintf("case%d-%s-%d", i, ds, nMap))
}

func testURLTopExample(rounds RoundsArgs) {
	if len(rounds) == 0 {
		log.Fatalln("no rounds arguments, please finish your code")
	}
	mr := GetMRCluster()

	// run all cases
	gens := AllCaseGenFs()
	dataSize, nMapFiles := testDataScale()
	for k := range dataSize {
		//	for i, gen := range gens {
		nums := generateRandomNumber(0, 5, nCase)
		for count := 0; count < nCase; count++ {
			i := nums[count]
			gen := gens[i]
			// generate data
			prefix := dataPrefix(i, dataSize[k], nMapFiles[k])
			c := gen(prefix, int(dataSize[k]), nMapFiles[k])

			runtime.GC()

			// run map-reduce rounds
			begin := time.Now()
			inputFiles := c.MapFiles
			for idx, r := range rounds {
				jobName := fmt.Sprintf("Case%d-Round%d", i, idx)
				ch := mr.Submit(jobName, prefix, r.MapFunc, r.ReduceFunc, inputFiles, r.NReduce)
				inputFiles = <-ch
			}
			cost := time.Since(begin)

			// check result
			if len(inputFiles) != 1 {
				panic("the length of result file list should be 1")
			}
			result := inputFiles[0]

			if errMsg, ok := CheckFile(c.ResultFile, result); !ok {
				log.Fatalln("Case%d FAIL, dataSize=%v, nMapFiles=%v, cost=%v\n%v\n", i, dataSize[k], nMapFiles[k], cost, errMsg)
			} else {
				fmt.Printf("Case%d PASS, dataSize=%v, nMapFiles=%v, cost=%v\n", i, dataSize[k], nMapFiles[k], cost)
			}
		}
	}
}

func main() {
	flag.Parse()

	// ==================== CPUProfile ======================
	if *cpuprofile != "" {
		f, err := os.Create(*cpuprofile)
		if err != nil {
			log.Fatal("could not create CPU profile: ", err)
		}
		defer f.Close()
		if err := pprof.StartCPUProfile(f); err != nil {
			log.Fatal("could not start CPU profile: ", err)
		}
		defer pprof.StopCPUProfile()
	}

	// =========== count number of goroutine running every 100s ===============
	if *interval != "" {
		log.SetFlags(log.Ltime | log.LUTC)
		log.SetOutput(os.Stdout)

		go func() {
			goroutines := pprof.Lookup("goroutine")
			if seconds, err := strconv.Atoi((*interval)); err != nil {
				log.Fatal(err)
			} else {
				for range time.Tick(time.Duration(seconds) * time.Second) {
					log.Printf("*****************************************\n**************goroutine count: %d***********\n", goroutines.Count())
				}
			}
		}()
	}

	// ======== running code here ============
	rounds := URLTop10(GetMRCluster().NWorkers())
	testURLTopExample(rounds)

	// =========== MemProfile ============
	if *memprofile != "" {
		f, err := os.Create(*memprofile)
		if err != nil {
			log.Fatal("could not create memory profile: ", err)
		}
		defer f.Close()
		runtime.GC() // get up-to-date statistics
		if err := pprof.WriteHeapProfile(f); err != nil {
			log.Fatal("could not write memory profile: ", err)
		}
	}

}
